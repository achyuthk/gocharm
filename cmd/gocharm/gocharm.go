package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"github.com/kr/fs"
	"gopkg.in/juju/charm.v4"
	"gopkg.in/yaml.v1"
	"launchpad.net/errgo/errors"
)

const hookPackage = "github.com/juju/gocharm/hook"

const hookMainCode = `
// This file is automatically generated. Do not edit.

package main
import (
	"fmt"
	runhook "runhook"
	"` + hookPackage + `"
	"os"
)

func main() {
	r := hook.NewRegistry()
	runhook.RegisterHooks(r)
	if err := hook.Main(r); err != nil {
		fmt.Fprintf(os.Stderr, "runhook: %v\n", err)
		os.Exit(1)
	}
}
`

func processCharm(dir *charm.CharmDir) {
	isGo, err := isGoCharm(dir)
	if err != nil {
		warningf("cannot determine if %q is a Go charm: %v", dir.Path, err)
		return
	}
	if !isGo {
		if *verbose {
			log.Printf("ignoring non-Go charm %s", dir.Path)
		}
		return
	}
	if *verbose {
		log.Printf("processing %v", dir.Path)
	}
	doneSomething, err := processGoCharm(dir)
	if err != nil {
		if *verbose {
			log.Printf("error info: %s", errors.Info(err))
		}
		errorf("failed compile or test charm %q: %v", dir.Path, err)
		return
	}
	if !doneSomething {
		return
	}
	if err := dir.SetDiskRevision(dir.Revision() + 1); err != nil {
		errorf("cannot bump revision on %q: %v", dir.Path, err)
	}
	_, series := filepath.Split(filepath.Dir(dir.Path))
	fmt.Printf("local:%s/%s-%d\n", series, dir.Meta().Name, dir.Revision())
}

func processGoCharm(dir *charm.CharmDir) (doneSomething bool, err error) {
	defer os.RemoveAll(filepath.Join(dir.Path, "pkg"))
	if *test {
		return false, errors.Wrap(testCharm(dir))
	}
	if err := compile(dir, "runhook", hookMainCode, true); err != nil {
		return false, errors.Wrapf(err, "cannot build hooks main package")
	}
	if _, err := os.Stat(filepath.Join(dir.Path, "bin", "runhook")); err != nil {
		return false, errors.New("runhook command not built")
	}
	info, err := registeredCharmInfo(dir)
	if err != nil {
		return false, errors.Wrap(err)
	}

	// TODO change writeHooks, writeMeta and writeConfig
	// so that they also return doneSomething.

	// We always want to generate a stop hook.
	info.Hooks["stop"] = true
	if err := writeHooks(dir, info.Hooks); err != nil {
		return false, errors.Wrapf(err, "cannot write hooks to charm")
	}
	if err := writeMeta(dir, info.Relations); err != nil {
		return false, errors.Wrapf(err, "cannot write metadata.yaml")
	}
	if err := writeConfig(dir, info.Config); err != nil {
		return false, errors.Wrapf(err, "cannot write config.yaml")
	}

	// Sanity check that the new config files parse correctly.
	_, err = charm.ReadCharmDir(dir.Path)
	if err != nil {
		return false, errors.Wrapf(err, "charm will not read correctly; we've broken it, sorry")
	}
	return true, nil
}

func writeMeta(dir *charm.CharmDir, relations map[string]charm.Relation) error {
	meta := *dir.Meta()
	meta.Provides = make(map[string]charm.Relation)
	meta.Requires = make(map[string]charm.Relation)
	meta.Peers = make(map[string]charm.Relation)

	for name, rel := range relations {
		switch rel.Role {
		case charm.RoleProvider:
			meta.Provides[name] = rel
		case charm.RoleRequirer:
			meta.Requires[name] = rel
		case charm.RolePeer:
			meta.Peers[name] = rel
		default:
			return errors.Newf("unknown role %q in relation", rel.Role)
		}
	}
	data, err := yaml.Marshal(&meta)
	if err != nil {
		return errors.Wrapf(err, "cannot marshal metadata.yaml")
	}
	if err := ioutil.WriteFile(filepath.Join(dir.Path, "metadata.yaml"), data, 0666); err != nil {
		return errors.Wrap(err)
	}
	return nil
}

func writeConfig(dir *charm.CharmDir, config map[string]charm.Option) error {
	configPath := filepath.Join(dir.Path, "config.yaml")
	if len(config) == 0 {
		return os.Remove(configPath)
	}
	data, err := yaml.Marshal(&charm.Config{
		Options: config,
	})
	if err != nil {
		return errors.Wrapf(err, "cannot marshal config.yaml")
	}
	if err := ioutil.WriteFile(configPath, data, 0666); err != nil {
		return errors.Wrap(err)
	}
	return nil
}

func isGoCharm(dir *charm.CharmDir) (bool, error) {
	info, err := os.Stat(filepath.Join(dir.Path, "src/runhook"))
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, errors.Wrap(err)
	}
	if !info.IsDir() {
		return false, nil
	}
	return true, nil
}

func setenv(env []string, entry string) []string {
	i := strings.Index(entry, "=")
	if i == -1 {
		panic("no = in environment entry")
	}
	prefix := entry[0 : i+1]
	for i, e := range env {
		if strings.HasPrefix(e, prefix) {
			env[i] = entry
			return env
		}
	}
	return append(env, entry)
}

func compile(dir *charm.CharmDir, binaryName string, mainCode string, crossCompile bool) error {
	env := setenv(os.Environ(),
		fmt.Sprintf("GOPATH=%s:%s", dir.Path, os.Getenv("GOPATH")),
	)
	if crossCompile {
		env = setenv(env, "CGOENABLED=false")
		env = setenv(env, "GOARCH=amd64")
		env = setenv(env, "GOOS=linux")
	}
	mainDir := filepath.Join(dir.Path, "src", "_main", binaryName)
	if err := os.MkdirAll(mainDir, 0777); err != nil {
		return errors.Wrap(err)
	}
	if err := ioutil.WriteFile(filepath.Join(mainDir, "main.go"), []byte(mainCode), 0666); err != nil {
		return errors.Wrap(err)
	}
	c := exec.Command("go", "build", "-o", filepath.Join(dir.Path, "bin", binaryName), "_main/"+binaryName)
	c.Stdout = os.Stdout
	c.Stderr = os.Stderr
	c.Env = env
	if err := c.Run(); err != nil {
		return errors.Wrapf(err, "failed to build")
	}
	return nil
}

func testCharm(dir *charm.CharmDir) error {
	pkgs, err := packagesInDir(dir.Path)
	if err != nil {
		return errors.Wrap(err)
	}
	env := append(os.Environ(),
		fmt.Sprintf("GOPATH=%s:%s:%s", dir.Path, os.Getenv("GOPATH")),
	)
	args := make([]string, 0, len(pkgs)+1)
	args = append(args, "test")
	args = append(args, pkgs...)
	if err := run(env, "go", args...); err != nil {
		return errors.Wrap(err)
	}
	return nil
}

func packagesInDir(dir string) ([]string, error) {
	pkgs := make(map[string]bool)
	w := fs.Walk(dir)
	srcPrefix := filepath.Join(dir, "src")
	for w.Step() {
		if err := w.Err(); err != nil {
			return nil, errors.Wrap(err)
		}
		if p := w.Path(); strings.HasSuffix(p, ".go") && strings.HasPrefix(p, srcPrefix) {
			parent, _ := filepath.Split(p)
			pkgs[strings.TrimPrefix(parent, srcPrefix)] = true
		}
	}
	var all []string
	for path := range pkgs {
		all = append(all, path)
	}
	sort.Strings(all)
	return all, nil
}

func run(env []string, cmd string, args ...string) error {
	c := exec.Command("go", "test", "./...")
	c.Stdout = os.Stdout
	c.Stderr = os.Stderr
	c.Env = env
	return errors.Wrap(c.Run())
}

func warningf(f string, a ...interface{}) {
	fmt.Fprintf(os.Stderr, "gocharm: warning: %s\n", fmt.Sprintf(f, a...))
}

func errorf(f string, a ...interface{}) {
	exitCode = 1
	fmt.Fprintf(os.Stderr, "gocharm: %s\n", fmt.Sprintf(f, a...))
}

func fatalf(f string, a ...interface{}) {
	errorf(f, a...)
	os.Exit(2)
}
