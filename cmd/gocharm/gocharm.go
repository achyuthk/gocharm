package main

import (
	"bytes"
	"fmt"
	"go/build"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"gopkg.in/juju/charm.v4"
	"gopkg.in/yaml.v1"
	"launchpad.net/errgo/errors"
)

const (
	hookPackage    = "github.com/juju/gocharm/hook"
	autogenMessage = `This file is automatically generated. Do not edit.`
)

var hookMainCode = template.Must(template.New("").Parse(`
// {{.AutogenMessage}}

package main

import (
	"fmt"
	"os"
	charm {{.CharmPackage | printf "%q"}}
	{{.HookPackage | printf "%q"}}
)

func nop() error {
	return nil
}

func main() {
	r := hook.NewRegistry()
	charm.RegisterHooks(r)
	hook.RegisterMainHooks(r)
	ctxt, state, err := hook.NewContextFromEnvironment(r)
	if err != nil {
		fatalf("cannot create context: %v", err)
	}
	defer ctxt.Close()
	if err := hook.Main(r, ctxt, state); err != nil {
		fatalf("%v", err)
	}
}

func fatalf(f string, a ...interface{}) {
	fmt.Fprintf(os.Stderr, "runhook: %s\n", fmt.Sprintf(f, a...))
	os.Exit(1)
}
`))

type buildCharmParams struct {
	// pkg specifies the package that the hook will be built from.
	pkg *build.Package

	// charmDir specifies the destination directory to write
	// the charm files to.
	charmDir string

	// tempDir holds a temporary directory to use for
	// any temporary build artifacts.
	tempDir string
}

// buildCharm builds the runhook executable,
// and all the other charm pieces (hooks, metadata.yaml,
// config.yaml). It puts the runhook source file into goFile
// and the runhook executable into exe.
func buildCharm(p buildCharmParams) error {
	code, err := generateCode(hookMainCode, p.pkg.ImportPath)
	if err != nil {
		return errors.Wrapf(err, "cannot generate main code")
	}
	exe := filepath.Join(p.charmDir, "bin", "runhook")
	goFile := filepath.Join(p.charmDir, "src", "runhook", "runhook.go")
	if err := compile(goFile, exe, code, true); err != nil {
		return errors.Wrapf(err, "cannot build hooks main package")
	}
	if _, err := os.Stat(exe); err != nil {
		return errors.New("runhook command not built")
	}
	info, err := registeredCharmInfo(p.pkg.ImportPath, p.tempDir)
	if err != nil {
		return errors.Wrap(err)
	}

	if err := writeHooks(p.charmDir, info.Hooks); err != nil {
		return errors.Wrapf(err, "cannot write hooks to charm")
	}
	if err := writeMeta(p.pkg, p.charmDir, info.Relations); err != nil {
		return errors.Wrapf(err, "cannot write metadata.yaml")
	}
	if err := writeConfig(p.charmDir, info.Config); err != nil {
		return errors.Wrapf(err, "cannot write config.yaml")
	}

	// Sanity check that the new config files parse correctly.
	_, err = charm.ReadCharmDir(p.charmDir)
	if err != nil {
		return errors.Wrapf(err, "charm will not read correctly; we've broken it, sorry")
	}
	return nil
}

// writeHooks ensures that the charm has the given set of hooks.
// TODO write install and start hooks even if they're not registered,
// because otherwise it won't be treated as a valid charm.
func writeHooks(charmDir string, hooks []string) error {
	if *verbose {
		log.Printf("writing hooks in %s", charmDir)
	}
	hookDir := filepath.Join(charmDir, "hooks")
	if err := os.MkdirAll(hookDir, 0777); err != nil {
		return errors.Wrapf(err, "failed to make hooks directory")
	}
	infos, err := ioutil.ReadDir(hookDir)
	if err != nil {
		return errors.Wrap(err)
	}
	if *verbose {
		log.Printf("found %d existing hooks", len(infos))
	}
	// Add any new hooks we need to the charm directory.
	for _, hookName := range hooks {
		hookPath := filepath.Join(hookDir, hookName)
		if *verbose {
			log.Printf("creating hook %s", hookPath)
		}
		if err := ioutil.WriteFile(hookPath, hookStub(hookName), 0755); err != nil {
			return errors.Wrap(err)
		}
	}
	return nil
}

const hookStubTemplate = `#!/bin/sh
$CHARM_DIR/bin/runhook %s
`

func hookStub(hookName string) []byte {
	return []byte(fmt.Sprintf(hookStubTemplate, hookName))
}

func writeMeta(pkg *build.Package, charmDir string, relations map[string]charm.Relation) error {
	metaFile, err := os.Open(filepath.Join(pkg.Dir, "metadata.yaml"))
	if err != nil {
		return errors.Wrap(err)
	}
	defer metaFile.Close()
	meta, err := charm.ReadMeta(metaFile)
	if err != nil {
		return errors.Wrapf(err, "cannot read metadata.yaml from %q", pkg.Dir)
	}
	// The metadata name must match the directory name otherwise
	// juju deploy will ignore the charm.
	meta.Name = filepath.Base(pkg.Dir)
	meta.Provides = make(map[string]charm.Relation)
	meta.Requires = make(map[string]charm.Relation)
	meta.Peers = make(map[string]charm.Relation)

	for name, rel := range relations {
		switch rel.Role {
		case charm.RoleProvider:
			meta.Provides[name] = rel
		case charm.RoleRequirer:
			meta.Requires[name] = rel
		case charm.RolePeer:
			meta.Peers[name] = rel
		default:
			return errors.Newf("unknown role %q in relation", rel.Role)
		}
	}
	if err := writeYAML(filepath.Join(charmDir, "metadata.yaml"), meta); err != nil {
		return errors.Wrapf(err, "cannot write metadata.yaml")
	}
	return nil
}

const yamlAutogenComment = "# " + autogenMessage + "\n"

func writeYAML(file string, val interface{}) error {
	data, err := yaml.Marshal(val)
	if err != nil {
		return errors.Wrapf(err, "cannot marshal YAML")
	}
	data = append([]byte(yamlAutogenComment), data...)
	if err := ioutil.WriteFile(file, data, 0666); err != nil {
		return errors.Wrap(err)
	}
	return nil
}

func writeConfig(charmDir string, config map[string]charm.Option) error {
	configPath := filepath.Join(charmDir, "config.yaml")
	if len(config) == 0 {
		return nil
	}
	if err := writeYAML(configPath, &charm.Config{
		Options: config,
	}); err != nil {
		return errors.Wrapf(err, "cannot write config.yaml")
	}
	return nil
}

func setenv(env []string, entry string) []string {
	i := strings.Index(entry, "=")
	if i == -1 {
		panic("no = in environment entry")
	}
	prefix := entry[0 : i+1]
	for i, e := range env {
		if strings.HasPrefix(e, prefix) {
			env[i] = entry
			return env
		}
	}
	return append(env, entry)
}

type templateParams struct {
	AutogenMessage string
	CharmPackage   string
	HookPackage    string
}

func generateCode(tmpl *template.Template, charmPackage string) ([]byte, error) {
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateParams{
		CharmPackage:   charmPackage,
		HookPackage:    hookPackage,
		AutogenMessage: autogenMessage,
	}); err != nil {
		return nil, errors.Wrapf(err, "cannot generate Go code")
	}
	return buf.Bytes(), nil
}

func compile(goFile, exeFile string, mainCode []byte, crossCompile bool) error {
	env := os.Environ()
	if crossCompile {
		env = setenv(env, "CGOENABLED=false")
		env = setenv(env, "GOARCH=amd64")
		env = setenv(env, "GOOS=linux")
	}
	if err := os.MkdirAll(filepath.Dir(goFile), 0777); err != nil {
		return errors.Wrap(err)
	}
	if err := os.MkdirAll(filepath.Dir(exeFile), 0777); err != nil {
		return errors.Wrap(err)
	}
	if err := ioutil.WriteFile(goFile, mainCode, 0666); err != nil {
		return errors.Wrap(err)
	}
	if err := run(env, "go", "build", "-o", exeFile, goFile); err != nil {
		return errors.Wrapf(err, "failed to build")
	}
	return nil
}

func run(env []string, cmd string, args ...string) error {
	if *verbose {
		log.Printf("run %s %s", cmd, strings.Join(args, " "))
	}
	c := exec.Command(cmd, args...)
	c.Stdout = os.Stdout
	c.Stderr = os.Stderr
	c.Env = env
	return errors.Wrap(c.Run())
}

func warningf(f string, a ...interface{}) {
	fmt.Fprintf(os.Stderr, "gocharm: warning: %s\n", fmt.Sprintf(f, a...))
}

func errorf(f string, a ...interface{}) {
	exitCode = 1
	fmt.Fprintf(os.Stderr, "gocharm: %s\n", fmt.Sprintf(f, a...))
}

func fatalf(f string, a ...interface{}) {
	errorf(f, a...)
	os.Exit(2)
}
